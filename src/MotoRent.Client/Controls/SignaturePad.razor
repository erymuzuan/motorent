@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="signature-pad-container card" style="@GetContainerStyle()">
    <canvas @ref="m_canvasRef" id="@m_canvasId"
            style="width: 100%; height: @(Height)px; cursor: crosshair; touch-action: none;"
            @onmousedown="OnMouseDown"
            @onmousemove="OnMouseMove"
            @onmouseup="OnMouseUp"
            @onmouseleave="OnMouseUp"
            @ontouchstart="OnTouchStart"
            @ontouchmove="OnTouchMove"
            @ontouchend="OnTouchEnd"
            @ontouchstart:preventDefault="true"
            @ontouchmove:preventDefault="true">
    </canvas>
</div>

@code {
    [Parameter] public string Width { get; set; } = "100%";
    [Parameter] public int Height { get; set; } = 200;
    [Parameter] public string StrokeColor { get; set; } = "#000000";
    [Parameter] public int StrokeWidth { get; set; } = 2;
    [Parameter] public EventCallback<string> OnSignatureChanged { get; set; }

    private ElementReference m_canvasRef;
    private string m_canvasId = $"signature-canvas-{Guid.NewGuid():N}";
    private IJSObjectReference? m_jsModule;
    private bool m_isDrawing;
    private double m_lastX;
    private double m_lastY;
    private bool m_hasSignature;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            this.m_jsModule = await this.JS.InvokeAsync<IJSObjectReference>("import",
                "./_content/MotoRent.Client/js/signature-pad.js");

            await this.m_jsModule.InvokeVoidAsync("initCanvas", this.m_canvasRef, this.StrokeColor, this.StrokeWidth);
        }
    }

    private string GetContainerStyle()
    {
        return $"width: {this.Width}; background-color: white; border-radius: 4px;";
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        this.m_isDrawing = true;
        var pos = await this.GetCanvasPosition(e.ClientX, e.ClientY);
        this.m_lastX = pos.x;
        this.m_lastY = pos.y;
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (!this.m_isDrawing) return;

        var pos = await this.GetCanvasPosition(e.ClientX, e.ClientY);
        await this.DrawLine(this.m_lastX, this.m_lastY, pos.x, pos.y);
        this.m_lastX = pos.x;
        this.m_lastY = pos.y;
        this.m_hasSignature = true;
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (this.m_isDrawing && this.m_hasSignature)
        {
            this.m_isDrawing = false;
            await this.NotifySignatureChanged();
        }
        this.m_isDrawing = false;
    }

    private async Task OnTouchStart(TouchEventArgs e)
    {
        if (e.Touches.Length > 0)
        {
            this.m_isDrawing = true;
            var touch = e.Touches[0];
            var pos = await this.GetCanvasPosition(touch.ClientX, touch.ClientY);
            this.m_lastX = pos.x;
            this.m_lastY = pos.y;
        }
    }

    private async Task OnTouchMove(TouchEventArgs e)
    {
        if (!this.m_isDrawing || e.Touches.Length == 0) return;

        var touch = e.Touches[0];
        var pos = await this.GetCanvasPosition(touch.ClientX, touch.ClientY);
        await this.DrawLine(this.m_lastX, this.m_lastY, pos.x, pos.y);
        this.m_lastX = pos.x;
        this.m_lastY = pos.y;
        this.m_hasSignature = true;
    }

    private async Task OnTouchEnd(TouchEventArgs e)
    {
        if (this.m_isDrawing && this.m_hasSignature)
        {
            this.m_isDrawing = false;
            await this.NotifySignatureChanged();
        }
        this.m_isDrawing = false;
    }

    private async Task<(double x, double y)> GetCanvasPosition(double clientX, double clientY)
    {
        if (this.m_jsModule == null) return (0, 0);

        var result = await this.m_jsModule.InvokeAsync<double[]>("getCanvasPosition", this.m_canvasRef, clientX, clientY);
        return (result[0], result[1]);
    }

    private async Task DrawLine(double x1, double y1, double x2, double y2)
    {
        if (this.m_jsModule == null) return;
        await this.m_jsModule.InvokeVoidAsync("drawLine", this.m_canvasRef, x1, y1, x2, y2);
    }

    private async Task NotifySignatureChanged()
    {
        if (this.m_jsModule == null) return;

        var dataUrl = await this.m_jsModule.InvokeAsync<string>("getSignatureData", this.m_canvasRef);
        await this.OnSignatureChanged.InvokeAsync(dataUrl);
    }

    public async Task Clear()
    {
        if (this.m_jsModule == null) return;
        await this.m_jsModule.InvokeVoidAsync("clearCanvas", this.m_canvasRef);
        this.m_hasSignature = false;
        await this.OnSignatureChanged.InvokeAsync(null);
    }

    public async Task<string?> GetSignatureData()
    {
        if (this.m_jsModule == null || !this.m_hasSignature) return null;
        return await this.m_jsModule.InvokeAsync<string>("getSignatureData", this.m_canvasRef);
    }

    public async ValueTask DisposeAsync()
    {
        if (this.m_jsModule != null)
        {
            await this.m_jsModule.DisposeAsync();
        }
    }
}
