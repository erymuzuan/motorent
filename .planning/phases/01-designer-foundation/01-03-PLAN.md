---
phase: 01-designer-foundation
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - src/MotoRent.Client/Components/Designer/ElementsPalette.razor
  - src/MotoRent.Client/Components/Designer/ElementsPalette.razor.cs
  - src/MotoRent.Client/Components/Designer/ElementsPalette.razor.css
  - src/MotoRent.Client/Components/Designer/Elements/TextElementView.razor
  - src/MotoRent.Client/Components/Designer/Elements/ImageElementView.razor
  - src/MotoRent.Client/Components/Designer/Elements/ContainerElementView.razor
  - src/MotoRent.Client/Components/Designer/Elements/DividerElementView.razor
  - src/MotoRent.Client/Components/Designer/Elements/DateElementView.razor
  - src/MotoRent.Client/Components/Designer/Elements/SignatureElementView.razor
autonomous: true

must_haves:
  truths:
    - "Palette displays all 7 draggable element types"
    - "Each element type renders its preview in the palette"
    - "Element views render their content based on element properties"
  artifacts:
    - path: "src/MotoRent.Client/Components/Designer/ElementsPalette.razor"
      provides: "Palette component with draggable items"
      contains: "data-element-type"
    - path: "src/MotoRent.Client/Components/Designer/Elements/TextElementView.razor"
      provides: "Text element renderer"
      contains: "TextElement"
  key_links:
    - from: "ElementsPalette.razor"
      to: "TemplateElement types"
      via: "data-element-type attribute"
      pattern: "data-element-type"
    - from: "TextElementView.razor"
      to: "TextElement.cs"
      via: "Parameter binding"
      pattern: "\\[Parameter\\].*TextElement"
---

<objective>
Create the elements palette and individual element view components.

Purpose: Provide the draggable element source and rendering components for the designer canvas.
Output: ElementsPalette component, 6 element view components
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-designer-foundation/01-RESEARCH.md

# Domain model from Plan 01
@src/MotoRent.Domain/Templates/TemplateElement.cs
@src/MotoRent.Domain/Templates/Elements/TextElement.cs

# Existing component patterns
@src/MotoRent.Client/Controls/LocalizedComponentBase.cs
@src/MotoRent.Client/Components/Shared/LoadingSkeleton.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ElementsPalette Component</name>
  <files>
    src/MotoRent.Client/Components/Designer/ElementsPalette.razor
    src/MotoRent.Client/Components/Designer/ElementsPalette.razor.cs
    src/MotoRent.Client/Components/Designer/ElementsPalette.razor.css
  </files>
  <action>
Create folder `src/MotoRent.Client/Components/Designer/`.

Create `ElementsPalette.razor` with palette items for each element type:
- Text (icon: `ti ti-letter-t`)
- Image (icon: `ti ti-photo`)
- Two Columns (icon: `ti ti-columns-2`)
- Container (icon: `ti ti-box`)
- Divider (icon: `ti ti-separator-horizontal`)
- Date (icon: `ti ti-calendar`)
- Signature (icon: `ti ti-signature`)

Each palette item needs:
- `data-element-type` attribute with element type name (e.g., "TextElement")
- Icon and label display
- Class `palette-item` for styling

Component structure:
```razor
@inherits LocalizedComponentBase<ElementsPalette>

<div class="elements-palette" @ref="PaletteRef">
    @foreach (var item in PaletteItems)
    {
        <div class="palette-item" data-element-type="@item.TypeName">
            <i class="@item.Icon"></i>
            <span>@Localizer[item.Label]</span>
        </div>
    }
</div>
```

Create `ElementsPalette.razor.cs` code-behind:
- `[Parameter] public ElementReference PaletteRef { get; set; }` - expose for JS interop
- Static list of `PaletteItem` records with TypeName, Icon, Label

Create `ElementsPalette.razor.css` with scoped styles:
- `.elements-palette` - flex column, gap, padding
- `.palette-item` - flex row, cursor grab, padding, border, border-radius, hover state
- `.palette-item i` - icon sizing
- Drag ghost style will be handled by SortableJS classes

Use Tabler CSS classes where possible (e.g., `card`, `d-flex`).
  </action>
  <verify>
Run `dotnet build src/MotoRent.Client/` - should compile without errors.
  </verify>
  <done>
ElementsPalette component exists with 7 draggable element types and proper data attributes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Element View Components</name>
  <files>
    src/MotoRent.Client/Components/Designer/Elements/TextElementView.razor
    src/MotoRent.Client/Components/Designer/Elements/ImageElementView.razor
    src/MotoRent.Client/Components/Designer/Elements/ContainerElementView.razor
    src/MotoRent.Client/Components/Designer/Elements/DividerElementView.razor
    src/MotoRent.Client/Components/Designer/Elements/DateElementView.razor
    src/MotoRent.Client/Components/Designer/Elements/SignatureElementView.razor
  </files>
  <action>
Create folder `src/MotoRent.Client/Components/Designer/Elements/`.

Each view component takes an element as parameter and renders it visually.

**TextElementView.razor:**
```razor
@using MotoRent.Domain.Templates.Elements

<div class="text-element" style="@GetStyle()">
    @if (string.IsNullOrEmpty(Element.BindingPath))
    {
        @(string.IsNullOrEmpty(Element.Content) ? "[....]" : Element.Content)
    }
    else
    {
        <span class="binding-placeholder">[@Element.BindingPath]</span>
    }
</div>

@code {
    [Parameter, EditorRequired] public TextElement Element { get; set; } = null!;

    private string GetStyle() => $"font-size: {Element.FontSize}px; text-align: {Element.TextAlign ?? "left"}; font-weight: {Element.FontWeight ?? "normal"}; font-style: {Element.FontStyle ?? "normal"};";
}
```

**ImageElementView.razor:**
- Show placeholder box if no Source
- Show `<img>` with Source, MaxWidth, MaxHeight, ObjectFit if set
- Alt text display

**ContainerElementView.razor:**
- Render children recursively (use switch on element type)
- Apply Layout (vertical/horizontal/two-column via flexbox)
- Apply Gap, Padding, Border, Background styles

**DividerElementView.razor:**
- Render `<hr>` with Style, Thickness, Color

**DateElementView.razor:**
- Show format preview or binding path
- If BindingPath is null, show "Today: {Format}"
- If BindingPath set, show `[@BindingPath]`

**SignatureElementView.razor:**
- Show label
- Show signature line if ShowLine is true
- Use border-bottom for line effect

All components should:
- Be minimal (no code-behind needed)
- Apply element styles inline
- Handle null/empty states gracefully
  </action>
  <verify>
Run `dotnet build src/MotoRent.Client/` - should compile without errors.
  </verify>
  <done>
All 6 element view components exist and render their respective element types.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/MotoRent.Client/` compiles successfully
2. ElementsPalette renders 7 palette items with correct data-element-type attributes
3. Each element view component handles its element type's properties
4. TextElementView shows binding placeholder `[@Path]` when bound, `[....]` when unbound
5. ContainerElementView renders children recursively
</verification>

<success_criteria>
- Palette displays all element types with icons and labels
- Each element view renders appropriate visual preview
- Binding placeholders show `[....]` (unbound) or `[@Path]` (bound)
- Container can render nested elements
- All components compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-designer-foundation/01-03-SUMMARY.md`
</output>
