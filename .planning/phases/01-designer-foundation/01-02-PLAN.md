---
phase: 01-designer-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/MotoRent.Client/wwwroot/scripts/template-designer.js
  - src/MotoRent.Client/wwwroot/lib/sortablejs/Sortable.min.js
  - src/MotoRent.Client/Interops/DesignerJsInterop.cs
autonomous: true

must_haves:
  truths:
    - "SortableJS library is available in wwwroot"
    - "JS module can initialize sortable instances on DOM elements"
    - "Blazor can invoke JS functions and receive callbacks"
  artifacts:
    - path: "src/MotoRent.Client/wwwroot/lib/sortablejs/Sortable.min.js"
      provides: "SortableJS library"
      min_lines: 1
    - path: "src/MotoRent.Client/wwwroot/scripts/template-designer.js"
      provides: "Designer interop module"
      contains: "export function initDesigner"
    - path: "src/MotoRent.Client/Interops/DesignerJsInterop.cs"
      provides: "C# interop wrapper"
      contains: "class DesignerJsInterop"
  key_links:
    - from: "DesignerJsInterop.cs"
      to: "template-designer.js"
      via: "ES module import"
      pattern: "import.*template-designer.js"
    - from: "template-designer.js"
      to: "Sortable.min.js"
      via: "Sortable constructor"
      pattern: "new Sortable"
---

<objective>
Set up SortableJS library and create the JavaScript interop layer for drag-and-drop.

Purpose: Enable communication between Blazor components and JavaScript for drag operations. This runs parallel to domain model creation.
Output: SortableJS library, ES module for designer, C# interop class
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-designer-foundation/01-RESEARCH.md

# Existing patterns to follow
@src/MotoRent.Client/Interops/GoogleMapJsInterop.cs
@src/MotoRent.Client/wwwroot/scripts/google-map.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SortableJS Library</name>
  <files>
    src/MotoRent.Client/wwwroot/lib/sortablejs/Sortable.min.js
  </files>
  <action>
Create the directory `src/MotoRent.Client/wwwroot/lib/sortablejs/`.

Download SortableJS 1.15.3 minified from CDN and save to the lib folder.

Use curl or direct download:
```
curl -o src/MotoRent.Client/wwwroot/lib/sortablejs/Sortable.min.js https://cdn.jsdelivr.net/npm/sortablejs@1.15.3/Sortable.min.js
```

Alternative: Create the file with the minified content from the official CDN.

Note: The library should be loaded via script tag in _Host.cshtml (or index.html for WASM). Add the script reference:
```html
<script src="lib/sortablejs/Sortable.min.js"></script>
```
  </action>
  <verify>
File exists at `src/MotoRent.Client/wwwroot/lib/sortablejs/Sortable.min.js` and is non-empty.
  </verify>
  <done>
SortableJS library file exists in wwwroot/lib directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Designer JavaScript Module</name>
  <files>
    src/MotoRent.Client/wwwroot/scripts/template-designer.js
  </files>
  <action>
Create ES module following the google-map.js pattern.

Key functions:

**initDesigner(canvasElement, paletteElement, dotNetRef)**
- Initialize SortableJS on both canvas and palette
- Canvas config: `group: 'template-elements'`, `animation: 150`, `ghostClass: 'element-ghost'`, `chosenClass: 'element-chosen'`, `delay: 150`, `touchStartThreshold: 5`
- Palette config: `group: { name: 'template-elements', pull: 'clone', put: false }`, `sort: false`
- On `onEnd` event: Call `dotNetRef.invokeMethodAsync('OnElementReordered', { elementId, oldIndex, newIndex })`
- On `onAdd` event: Remove cloned element (`evt.item.remove()`), call `dotNetRef.invokeMethodAsync('OnElementAdded', { elementType, index })`

**selectElement(canvasElement, elementId)**
- Reserved for future selection effects (CSS selection handled by Blazor)

**removeElement(canvasElement, elementId)**
- Remove element from sortable instance if needed

**dispose(canvasElement)**
- Destroy sortable instances and clean up

Use Map to store designer instances by canvas element for proper cleanup.

Key pattern - prevent DOM desync:
```javascript
onAdd: async (evt) => {
    const elementType = evt.item.dataset.elementType;
    const newIndex = evt.newIndex;
    // CRITICAL: Remove cloned element - Blazor will re-render
    evt.item.remove();
    await dotNetRef.invokeMethodAsync('OnElementAdded', {
        elementType: elementType,
        index: newIndex
    });
}
```
  </action>
  <verify>
File exists and contains `export function initDesigner`, `export function dispose`, and `new Sortable` calls.
  </verify>
  <done>
ES module exists with SortableJS initialization and Blazor callback support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create C# Interop Class</name>
  <files>
    src/MotoRent.Client/Interops/DesignerJsInterop.cs
  </files>
  <action>
Create C# interop class following GoogleMapJsInterop.cs pattern exactly.

Class structure:
```csharp
public class DesignerJsInterop : IAsyncDisposable
{
    private readonly Lazy<Task<IJSObjectReference>> m_moduleTask;
    private bool m_disposed;

    public DesignerJsInterop(IJSRuntime jsRuntime)
    {
        m_moduleTask = new(() => jsRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./scripts/template-designer.js").AsTask());
    }
}
```

Methods:
- `InitDesignerAsync(ElementReference canvas, ElementReference palette, DotNetObjectReference<T> dotNetRef)` - initialize sortable instances
- `SelectElementAsync(ElementReference canvas, string elementId)` - future selection effects
- `RemoveElementAsync(ElementReference canvas, string elementId)` - remove element
- `DisposeAsync()` - clean up module

Add DTOs for callback arguments:
```csharp
public record ElementReorderArgs(string ElementId, int OldIndex, int NewIndex);
public record ElementAddArgs(string ElementType, int Index);
```

Follow error handling pattern from GoogleMapJsInterop - catch exceptions in DisposeAsync.
  </action>
  <verify>
Run `dotnet build src/MotoRent.Client/` - should compile without errors.
  </verify>
  <done>
DesignerJsInterop class compiles and follows existing interop patterns.
  </done>
</task>

</tasks>

<verification>
1. SortableJS library file exists in wwwroot/lib
2. `template-designer.js` exports initDesigner and dispose functions
3. `DesignerJsInterop.cs` compiles successfully
4. Interop class follows Lazy module loading pattern
5. JS module uses Map for instance tracking
</verification>

<success_criteria>
- SortableJS v1.15.3 available in wwwroot
- ES module with initDesigner, selectElement, removeElement, dispose exports
- C# interop class with async methods and IAsyncDisposable
- Clone-from-palette pattern implemented (pull: 'clone')
- DOM removal in onAdd handler to prevent Blazor desync
</success_criteria>

<output>
After completion, create `.planning/phases/01-designer-foundation/01-02-SUMMARY.md`
</output>
