---
phase: 05-refunds-corrections
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/MotoRent.Services/TillService.cs
  - src/MotoRent.Services/ManagerPinService.cs
autonomous: true

must_haves:
  truths:
    - "Manager PIN can be set with secure hashing"
    - "Manager PIN can be verified for void approval"
    - "3 wrong attempts locks out for 5 minutes"
    - "Void transaction creates compensating entry and marks original"
    - "Foreign currency void reverses exact foreign amounts"
  artifacts:
    - path: "src/MotoRent.Services/ManagerPinService.cs"
      provides: "PIN hashing and verification with lockout"
      exports: ["SetPinAsync", "VerifyPinAsync", "IsLockedOut"]
    - path: "src/MotoRent.Services/TillService.cs"
      provides: "VoidTransactionAsync and RecordRefundAsync methods"
      contains: "VoidTransactionAsync"
  key_links:
    - from: "TillService.VoidTransactionAsync"
      to: "TillTransaction.IsVoided"
      via: "Marks original as voided"
      pattern: "IsVoided = true"
    - from: "ManagerPinService.VerifyPinAsync"
      to: "User.ManagerPinHash"
      via: "PBKDF2 comparison"
      pattern: "Rfc2898DeriveBytes"
---

<objective>
Create ManagerPinService for PIN management with lockout, and extend TillService with void and refund operations.

Purpose: Core business logic for void authorization and till adjustments. Enables managers to set PINs for void approval, and staff to process voids with proper authorization.

Output: ManagerPinService with hash/verify/lockout logic, TillService extended with VoidTransactionAsync and RecordRefundAsync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-refunds-corrections/05-CONTEXT.md
@.planning/phases/05-refunds-corrections/05-RESEARCH.md
@.planning/phases/05-refunds-corrections/05-01-SUMMARY.md

# Existing service to extend
@src/MotoRent.Services/TillService.cs
@src/MotoRent.Domain/Core/User.cs
@src/MotoRent.Domain/Entities/TillTransaction.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ManagerPinService</name>
  <files>src/MotoRent.Services/ManagerPinService.cs</files>
  <action>
Create new ManagerPinService with PIN hashing, verification, and lockout logic:

```csharp
using System.Security.Cryptography;
using MotoRent.Domain.Core;
using MotoRent.Domain.DataContext;

namespace MotoRent.Services;

/// <summary>
/// Service for manager PIN management and verification.
/// Used for void approval workflow.
/// </summary>
public class ManagerPinService(CoreDataContext coreContext)
{
    private readonly CoreDataContext m_coreContext = coreContext;

    // Track lockouts per user (in-memory for MVP, consider server-side persistence for production)
    private static readonly Dictionary<string, LockoutInfo> s_lockouts = new();
    private static readonly object s_lockoutLock = new();

    private const int c_maxAttempts = 3;
    private const int c_lockoutMinutes = 5;
    private const int c_pbkdf2Iterations = 10000;
    private const int c_hashByteSize = 32;
    private const int c_saltByteSize = 16;

    /// <summary>
    /// Sets or updates a manager's PIN.
    /// PIN must be 4-6 digits.
    /// </summary>
    public async Task<SubmitOperation> SetPinAsync(string userName, string pin, string changedBy)
    {
        // Validate PIN format
        if (string.IsNullOrWhiteSpace(pin) || pin.Length < 4 || pin.Length > 6 || !pin.All(char.IsDigit))
            return SubmitOperation.CreateFailure("PIN must be 4-6 digits");

        var user = await m_coreContext.LoadOneAsync<User>(u => u.UserName == userName);
        if (user == null)
            return SubmitOperation.CreateFailure("User not found");

        // Generate salt and hash
        var salt = GenerateSalt();
        var hash = HashPin(pin, salt);

        user.ManagerPinSalt = Convert.ToBase64String(salt);
        user.ManagerPinHash = hash;

        using var session = m_coreContext.OpenSession(changedBy);
        session.Attach(user);
        return await session.SubmitChanges("SetManagerPin");
    }

    /// <summary>
    /// Verifies a manager's PIN for void approval.
    /// Returns success if PIN matches and not locked out.
    /// Tracks failed attempts and enforces lockout.
    /// </summary>
    public (bool IsValid, string? Error, int RemainingAttempts) VerifyPin(User manager, string enteredPin)
    {
        // Check lockout
        var lockoutInfo = GetLockoutInfo(manager.UserName);
        if (lockoutInfo.IsLockedOut)
        {
            var remainingSeconds = (int)(lockoutInfo.LockoutUntil!.Value - DateTimeOffset.Now).TotalSeconds;
            return (false, $"Too many attempts. Try again in {remainingSeconds} seconds.", 0);
        }

        // Verify PIN is set
        if (string.IsNullOrEmpty(manager.ManagerPinHash) || string.IsNullOrEmpty(manager.ManagerPinSalt))
            return (false, "Manager PIN not configured", 0);

        // Verify PIN
        var expectedHash = manager.ManagerPinHash;
        var salt = Convert.FromBase64String(manager.ManagerPinSalt);
        var actualHash = HashPin(enteredPin, salt);

        if (actualHash == expectedHash)
        {
            // Success - clear any failed attempts
            ClearLockout(manager.UserName);
            return (true, null, c_maxAttempts);
        }

        // Failed attempt
        var remaining = RecordFailedAttempt(manager.UserName);
        if (remaining == 0)
            return (false, $"Incorrect PIN. Account locked for {c_lockoutMinutes} minutes.", 0);

        return (false, $"Incorrect PIN. {remaining} attempts remaining.", remaining);
    }

    /// <summary>
    /// Checks if a user is currently locked out.
    /// </summary>
    public bool IsLockedOut(string userName)
    {
        return GetLockoutInfo(userName).IsLockedOut;
    }

    /// <summary>
    /// Gets seconds remaining in lockout, or 0 if not locked out.
    /// </summary>
    public int GetLockoutSecondsRemaining(string userName)
    {
        var info = GetLockoutInfo(userName);
        if (!info.IsLockedOut) return 0;
        return (int)(info.LockoutUntil!.Value - DateTimeOffset.Now).TotalSeconds;
    }

    /// <summary>
    /// Removes a manager's PIN (used by admin or when manager leaves).
    /// </summary>
    public async Task<SubmitOperation> RemovePinAsync(string userName, string changedBy)
    {
        var user = await m_coreContext.LoadOneAsync<User>(u => u.UserName == userName);
        if (user == null)
            return SubmitOperation.CreateFailure("User not found");

        user.ManagerPinSalt = null;
        user.ManagerPinHash = null;

        using var session = m_coreContext.OpenSession(changedBy);
        session.Attach(user);
        return await session.SubmitChanges("RemoveManagerPin");
    }

    #region Private Helpers

    private static byte[] GenerateSalt()
    {
        var salt = new byte[c_saltByteSize];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(salt);
        return salt;
    }

    private static string HashPin(string pin, byte[] salt)
    {
        using var pbkdf2 = new Rfc2898DeriveBytes(
            pin,
            salt,
            c_pbkdf2Iterations,
            HashAlgorithmName.SHA256);
        return Convert.ToBase64String(pbkdf2.GetBytes(c_hashByteSize));
    }

    private static LockoutInfo GetLockoutInfo(string userName)
    {
        lock (s_lockoutLock)
        {
            if (!s_lockouts.TryGetValue(userName, out var info))
                return new LockoutInfo();

            // Check if lockout has expired
            if (info.LockoutUntil.HasValue && info.LockoutUntil <= DateTimeOffset.Now)
            {
                s_lockouts.Remove(userName);
                return new LockoutInfo();
            }

            return info;
        }
    }

    private static int RecordFailedAttempt(string userName)
    {
        lock (s_lockoutLock)
        {
            if (!s_lockouts.TryGetValue(userName, out var info))
            {
                info = new LockoutInfo();
                s_lockouts[userName] = info;
            }

            info.FailedAttempts++;

            if (info.FailedAttempts >= c_maxAttempts)
            {
                info.LockoutUntil = DateTimeOffset.Now.AddMinutes(c_lockoutMinutes);
                return 0;
            }

            return c_maxAttempts - info.FailedAttempts;
        }
    }

    private static void ClearLockout(string userName)
    {
        lock (s_lockoutLock)
        {
            s_lockouts.Remove(userName);
        }
    }

    private class LockoutInfo
    {
        public int FailedAttempts { get; set; }
        public DateTimeOffset? LockoutUntil { get; set; }
        public bool IsLockedOut => LockoutUntil.HasValue && LockoutUntil > DateTimeOffset.Now;
    }

    #endregion
}
```

Key implementation notes:
- Uses PBKDF2 with SHA256 (10,000 iterations) for secure PIN hashing
- Static dictionary for lockout tracking (in-memory, acceptable for MVP)
- Thread-safe lockout operations with lock
- 3 attempts before 5-minute lockout per CONTEXT.md
  </action>
  <verify>Build succeeds: `dotnet build src/MotoRent.Services`</verify>
  <done>ManagerPinService exists with SetPinAsync, VerifyPin, IsLockedOut, GetLockoutSecondsRemaining methods</done>
</task>

<task type="auto">
  <name>Task 2: Extend TillService with void and refund operations</name>
  <files>src/MotoRent.Services/TillService.cs</files>
  <action>
Add a new region to TillService with void and refund methods. Add after the `#region Reports` section:

```csharp
#region Void and Refund Operations

/// <summary>
/// Voids a transaction with manager approval.
/// Creates a compensating entry and marks original as voided.
/// </summary>
/// <param name="transactionId">Transaction to void</param>
/// <param name="staffUserName">Staff initiating the void</param>
/// <param name="managerUserName">Manager approving the void (must be different from staff)</param>
/// <param name="reason">Reason for voiding</param>
/// <returns>Submit operation result</returns>
public async Task<SubmitOperation> VoidTransactionAsync(
    int transactionId,
    string staffUserName,
    string managerUserName,
    string reason)
{
    // Prevent self-approval
    if (staffUserName.Equals(managerUserName, StringComparison.OrdinalIgnoreCase))
        return SubmitOperation.CreateFailure("Staff cannot approve their own void");

    var original = await Context.LoadOneAsync<TillTransaction>(t => t.TillTransactionId == transactionId);
    if (original == null)
        return SubmitOperation.CreateFailure("Transaction not found");

    if (original.IsVoided)
        return SubmitOperation.CreateFailure("Transaction is already voided");

    // Check session is still open
    var session = await GetSessionByIdAsync(original.TillSessionId);
    if (session == null)
        return SubmitOperation.CreateFailure("Session not found");

    if (session.Status != TillSessionStatus.Open)
        return SubmitOperation.CreateFailure("Cannot void transactions in a closed session");

    // Create compensating entry (reverse direction)
    var compensating = new TillTransaction
    {
        TillSessionId = original.TillSessionId,
        TransactionType = TillTransactionType.VoidReversal,
        Direction = original.Direction == TillTransactionDirection.In
            ? TillTransactionDirection.Out
            : TillTransactionDirection.In,
        Amount = original.Amount,
        Currency = original.Currency,
        ExchangeRate = original.ExchangeRate,
        AmountInBaseCurrency = original.AmountInBaseCurrency,
        ExchangeRateSource = original.ExchangeRateSource,
        ExchangeRateId = original.ExchangeRateId,
        Description = $"VOID: {original.Description}",
        OriginalTransactionId = transactionId,
        TransactionTime = DateTimeOffset.Now,
        RecordedByUserName = staffUserName,
        Notes = $"Voided by {managerUserName}: {reason}",
        PaymentId = original.PaymentId,
        DepositId = original.DepositId,
        RentalId = original.RentalId
    };

    // Mark original as voided
    original.IsVoided = true;
    original.VoidedAt = DateTimeOffset.Now;
    original.VoidedByUserName = staffUserName;
    original.VoidReason = reason;
    original.VoidApprovedByUserName = managerUserName;

    // Update session balances (reverse the original effect)
    if (original.AffectsCash)
    {
        if (original.Direction == TillTransactionDirection.In)
        {
            session.TotalCashIn -= original.AmountInBaseCurrency;
            // Also reverse the currency balance
            if (session.CurrencyBalances.ContainsKey(original.Currency))
                session.CurrencyBalances[original.Currency] -= original.Amount;
        }
        else
        {
            session.TotalCashOut -= original.AmountInBaseCurrency;
            // For outflows, add back to currency balance
            if (session.CurrencyBalances.ContainsKey(original.Currency))
                session.CurrencyBalances[original.Currency] += original.Amount;
        }
    }

    // Handle non-cash payment type totals
    switch (original.TransactionType)
    {
        case TillTransactionType.CardPayment:
            session.TotalCardPayments -= original.AmountInBaseCurrency;
            break;
        case TillTransactionType.BankTransfer:
            session.TotalBankTransfers -= original.AmountInBaseCurrency;
            break;
        case TillTransactionType.PromptPay:
            session.TotalPromptPay -= original.AmountInBaseCurrency;
            break;
        case TillTransactionType.Drop:
            session.TotalDropped -= original.AmountInBaseCurrency;
            break;
        case TillTransactionType.TopUp:
            session.TotalToppedUp -= original.AmountInBaseCurrency;
            break;
    }

    using var persistenceSession = Context.OpenSession(staffUserName);
    persistenceSession.Attach(compensating);
    persistenceSession.Attach(original);
    persistenceSession.Attach(session);
    var result = await persistenceSession.SubmitChanges("VoidTransaction");

    // Link original to compensating after save (compensating now has ID)
    if (result.Succeeded)
    {
        original.RelatedTransactionId = compensating.TillTransactionId;
        using var linkSession = Context.OpenSession(staffUserName);
        linkSession.Attach(original);
        await linkSession.SubmitChanges("LinkVoidedTransaction");
    }

    return result;
}

/// <summary>
/// Records an overpayment refund to the till.
/// Always issued in THB cash regardless of original payment currency.
/// </summary>
/// <param name="sessionId">Current till session</param>
/// <param name="refundAmountThb">Refund amount in THB</param>
/// <param name="reason">Reason for refund</param>
/// <param name="originalPaymentIds">IDs of original payments being refunded</param>
/// <param name="rentalId">Related rental ID</param>
/// <param name="username">Staff recording the refund</param>
/// <returns>Submit operation result</returns>
public async Task<SubmitOperation> RecordOverpaymentRefundAsync(
    int sessionId,
    decimal refundAmountThb,
    string reason,
    List<int>? originalPaymentIds,
    int? rentalId,
    string username)
{
    var session = await GetSessionByIdAsync(sessionId);
    if (session == null)
        return SubmitOperation.CreateFailure("Session not found");

    if (session.Status != TillSessionStatus.Open)
        return SubmitOperation.CreateFailure("Session is not open");

    // Check THB balance (warning only, allow negative)
    var thbBalance = session.GetCurrencyBalance(SupportedCurrencies.THB);

    var transaction = new TillTransaction
    {
        TillSessionId = sessionId,
        TransactionType = TillTransactionType.OverpaymentRefund,
        Direction = TillTransactionDirection.Out,
        Amount = refundAmountThb,
        Currency = SupportedCurrencies.THB,
        ExchangeRate = 1.0m,
        AmountInBaseCurrency = refundAmountThb,
        ExchangeRateSource = "Base",
        Description = $"Overpayment refund: {reason}",
        RentalId = rentalId,
        TransactionTime = DateTimeOffset.Now,
        RecordedByUserName = username,
        Notes = originalPaymentIds != null
            ? $"Original payments: {string.Join(", ", originalPaymentIds)}"
            : null
    };

    // Update session totals
    session.TotalCashOut += refundAmountThb;
    session.CurrencyBalances[SupportedCurrencies.THB] -= refundAmountThb;

    using var persistenceSession = Context.OpenSession(username);
    persistenceSession.Attach(transaction);
    persistenceSession.Attach(session);
    return await persistenceSession.SubmitChanges("RecordOverpaymentRefund");
}

/// <summary>
/// Gets a transaction by ID.
/// </summary>
public async Task<TillTransaction?> GetTransactionByIdAsync(int transactionId)
{
    return await Context.LoadOneAsync<TillTransaction>(t => t.TillTransactionId == transactionId);
}

/// <summary>
/// Gets voided transactions for a session (for audit view).
/// Only managers should call this.
/// </summary>
public async Task<List<TillTransaction>> GetVoidedTransactionsAsync(int sessionId)
{
    var result = await Context.LoadAsync(
        Context.CreateQuery<TillTransaction>()
            .Where(t => t.TillSessionId == sessionId)
            .Where(t => t.IsVoided == true)
            .OrderByDescending(t => t.VoidedAt),
        page: 1, size: 100, includeTotalRows: false);
    return result.ItemCollection.ToList();
}

/// <summary>
/// Checks if a transaction can be voided.
/// Returns reason if not voidable.
/// </summary>
public async Task<(bool CanVoid, string? Reason)> CanVoidTransactionAsync(int transactionId)
{
    var transaction = await GetTransactionByIdAsync(transactionId);
    if (transaction == null)
        return (false, "Transaction not found");

    if (transaction.IsVoided)
        return (false, "Already voided");

    if (transaction.TransactionType == TillTransactionType.VoidReversal)
        return (false, "Cannot void a void reversal");

    var session = await GetSessionByIdAsync(transaction.TillSessionId);
    if (session == null)
        return (false, "Session not found");

    if (session.Status != TillSessionStatus.Open)
        return (false, "Session is closed");

    return (true, null);
}

#endregion
```

Key implementation notes:
- VoidTransactionAsync creates compensating entry and reverses all balance effects
- Self-approval prevention: staff cannot approve their own void
- Foreign currency voids reverse exact currency amounts (per CONTEXT.md)
- RecordOverpaymentRefundAsync always issues THB cash
- Session must be open to void (cannot void in closed session)
  </action>
  <verify>Build succeeds: `dotnet build src/MotoRent.Services`</verify>
  <done>TillService has VoidTransactionAsync, RecordOverpaymentRefundAsync, GetVoidedTransactionsAsync, CanVoidTransactionAsync methods</done>
</task>

<task type="auto">
  <name>Task 3: Register ManagerPinService in DI</name>
  <files>src/MotoRent.Server/Program.cs</files>
  <action>
Add ManagerPinService registration in the services configuration section, near where other services like TillService are registered:

```csharp
builder.Services.AddScoped<ManagerPinService>();
```

This allows the service to be injected into Blazor components and other services.

Look for the pattern where TillService is registered and add ManagerPinService nearby for consistency.
  </action>
  <verify>Build succeeds: `dotnet build src/MotoRent.Server`</verify>
  <done>ManagerPinService registered in DI container</done>
</task>

</tasks>

<verification>
1. `dotnet build src/MotoRent.Services` - compiles without errors
2. `dotnet build src/MotoRent.Server` - compiles without errors
3. ManagerPinService has SetPinAsync, VerifyPin, IsLockedOut, GetLockoutSecondsRemaining
4. TillService has VoidTransactionAsync, RecordOverpaymentRefundAsync methods
5. Void logic creates compensating entry with reversed direction
6. Self-approval is prevented
</verification>

<success_criteria>
- ManagerPinService created with secure PIN hashing
- Lockout logic enforces 3 attempts / 5 minutes
- TillService extended with void and refund operations
- Void creates compensating entry and marks original
- Foreign currency voids reverse exact amounts
- Build succeeds for Services and Server projects
</success_criteria>

<output>
After completion, create `.planning/phases/05-refunds-corrections/05-02-SUMMARY.md`
</output>
