---
phase: 01-exchange-rate-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/MotoRent.Domain/Entities/ExchangeRate.cs
  - src/MotoRent.Domain/Entities/Entity.cs
  - database/tables/MotoRent.ExchangeRate.sql
  - src/MotoRent.Services/ExchangeRateService.cs
  - src/MotoRent.Server/Program.cs
autonomous: true

must_haves:
  truths:
    - "ExchangeRate entity can be serialized and deserialized with JSON polymorphism"
    - "ExchangeRateService can get/set rates for a currency"
    - "Rate source (Manual/API) is tracked on each rate"
    - "SQL table exists with proper indexes for currency/active lookups"
  artifacts:
    - path: "src/MotoRent.Domain/Entities/ExchangeRate.cs"
      provides: "ExchangeRate entity with BuyRate, Currency, Source, EffectiveDate"
      min_lines: 40
    - path: "src/MotoRent.Services/ExchangeRateService.cs"
      provides: "CRUD operations for exchange rates"
      exports: ["ExchangeRateService", "GetCurrentRateAsync", "SetRateAsync", "GetAllCurrentRatesAsync", "ConvertToThbAsync"]
    - path: "database/tables/MotoRent.ExchangeRate.sql"
      provides: "SQL table with JSON column pattern"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/MotoRent.Domain/Entities/Entity.cs"
      to: "ExchangeRate"
      via: "JsonDerivedType attribute"
      pattern: "JsonDerivedType.*ExchangeRate"
    - from: "src/MotoRent.Server/Program.cs"
      to: "ExchangeRateService"
      via: "DI registration"
      pattern: "AddScoped.*ExchangeRateService"
---

<objective>
Create the ExchangeRate entity and service that form the foundation for all multi-currency operations.

Purpose: RATE-02, RATE-03, RATE-04 require an exchange rate entity with source tracking and audit trail. This plan creates the domain model and service layer that all other plans depend on.

Output: ExchangeRate entity, SQL table, ExchangeRateService with get/set/convert operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-exchange-rate-foundation/01-RESEARCH.md

# Existing patterns to follow
@src/MotoRent.Domain/Entities/Entity.cs
@src/MotoRent.Domain/Entities/ReceiptPayment.cs
@src/MotoRent.Services/TillService.cs
@database/tables/MotoRent.TillSession.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExchangeRate entity and SQL table</name>
  <files>
    src/MotoRent.Domain/Entities/ExchangeRate.cs
    src/MotoRent.Domain/Entities/Entity.cs
    database/tables/MotoRent.ExchangeRate.sql
  </files>
  <action>
    Create ExchangeRate entity following the existing Entity base class pattern:

    1. Create `src/MotoRent.Domain/Entities/ExchangeRate.cs`:
       - Inherit from Entity
       - Properties: ExchangeRateId (int), Currency (string, default SupportedCurrencies.USD), BuyRate (decimal), Source (string, default "Manual"), EffectiveDate (DateTimeOffset), ExpiresOn (DateTimeOffset?), ApiRate (decimal?), Notes (string?), IsActive (bool, default true)
       - Override GetId()/SetId() to use ExchangeRateId
       - Add static class ExchangeRateSources with constants: Manual, API, Adjusted

    2. Add JsonDerivedType attribute to Entity.cs:
       - Add `[JsonDerivedType(typeof(ExchangeRate), nameof(ExchangeRate))]` to Entity class
       - Place after the Till entities section with comment "// Exchange rate entities"

    3. Create `database/tables/MotoRent.ExchangeRate.sql`:
       - Follow MotoRent.TillSession.sql pattern
       - Schema placeholder: [<schema>]
       - Computed columns for indexing: Currency (CHAR(3)), BuyRate (DECIMAL(18,4)), Source (NVARCHAR(20)), IsActive (BIT), EffectiveDate (DATETIMEOFFSET PERSISTED), ExpiresOn (DATETIMEOFFSET PERSISTED)
       - Json column, audit columns (CreatedBy, ChangedBy, CreatedTimestamp, ChangedTimestamp)
       - Create index IX_ExchangeRate_Currency_Active on ([Currency], [IsActive])
       - Create index IX_ExchangeRate_EffectiveDate on ([EffectiveDate])

    Use decimal(18,4) for BuyRate - rates like CNY need precision (e.g., 5.1234 THB per CNY).
  </action>
  <verify>
    - `dotnet build src/MotoRent.Domain` compiles without errors
    - ExchangeRate.cs exists with all required properties
    - Entity.cs has JsonDerivedType attribute for ExchangeRate
    - SQL file follows the established pattern
  </verify>
  <done>
    ExchangeRate entity exists with BuyRate, Currency, Source, EffectiveDate properties. Entity.cs includes polymorphism attribute. SQL table script ready for deployment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExchangeRateService</name>
  <files>
    src/MotoRent.Services/ExchangeRateService.cs
    src/MotoRent.Server/Program.cs
  </files>
  <action>
    Create ExchangeRateService following TillService pattern:

    1. Create `src/MotoRent.Services/ExchangeRateService.cs`:
       - Constructor: `ExchangeRateService(RentalDataContext context)`
       - Private property: `RentalDataContext Context { get; }`

       Methods to implement:

       a) `GetCurrentRateAsync(string currency)` -> `Task<ExchangeRate?>`
          - Query for active rate where Currency matches, EffectiveDate <= now, and (ExpiresOn is null OR ExpiresOn > now)
          - Use Context.LoadOneAsync with predicate

       b) `GetAllCurrentRatesAsync()` -> `Task<List<ExchangeRate>>`
          - Query active rates, ordered by Currency
          - Filter expired in memory (complex OR condition)
          - Return list of current rates for all currencies

       c) `SetRateAsync(string currency, decimal buyRate, string source, string username, decimal? apiRate = null, string? notes = null)` -> `Task<SubmitOperation>`
          - Get current rate for currency (if exists)
          - Create new ExchangeRate with provided values, IsActive = true, EffectiveDate = now
          - If current rate exists, set IsActive = false and ExpiresOn = now
          - Use Context.OpenSession(username), Attach both entities, SubmitChanges("SetExchangeRate")

       d) `ConvertToThbAsync(string currency, decimal foreignAmount)` -> `Task<(decimal ThbAmount, decimal RateUsed)?>`
          - If currency is THB, return (foreignAmount, 1.0m)
          - Get current rate for currency
          - If null, return null (no rate configured)
          - Calculate: thbAmount = foreignAmount * rate.BuyRate
          - Return (thbAmount, rate.BuyRate)

       e) `GetRateHistoryAsync(string currency, int count = 10)` -> `Task<List<ExchangeRate>>`
          - Query rates for currency ordered by EffectiveDate descending
          - Useful for audit trail

    2. Register service in `src/MotoRent.Server/Program.cs`:
       - Add `builder.Services.AddScoped<ExchangeRateService>();`
       - Place near other service registrations (TillService, ReceiptService, etc.)
  </action>
  <verify>
    - `dotnet build src/MotoRent.Services` compiles without errors
    - `dotnet build src/MotoRent.Server` compiles without errors
    - ExchangeRateService has all five methods
    - Service is registered in Program.cs
  </verify>
  <done>
    ExchangeRateService exists with GetCurrentRateAsync, GetAllCurrentRatesAsync, SetRateAsync, ConvertToThbAsync, GetRateHistoryAsync methods. Service registered in DI container.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add repository registration and verify integration</name>
  <files>
    src/MotoRent.Domain/DataContext/ServiceCollectionExtensions.cs
  </files>
  <action>
    Register ExchangeRate repository following existing pattern:

    1. Open `src/MotoRent.Domain/DataContext/ServiceCollectionExtensions.cs`
    2. Find the section where repositories are registered (look for `AddSingleton<IRepository<...>>`)
    3. Add: `services.AddSingleton<IRepository<ExchangeRate>, Repository<ExchangeRate>>();`

    If ServiceCollectionExtensions.cs doesn't have repository registrations, check Program.cs for the pattern and add there instead.

    After adding the registration, verify the full build:
    - All projects compile
    - No missing type errors
  </action>
  <verify>
    - `dotnet build` (full solution) compiles without errors
    - Repository registration exists for ExchangeRate
    - ExchangeRateService can be resolved from DI (implicit from build success)
  </verify>
  <done>
    ExchangeRate repository registered. Full solution builds successfully. Foundation layer complete and ready for UI plans.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Full solution builds: `dotnet build`
2. Entity exists with required properties: ExchangeRateId, Currency, BuyRate, Source, EffectiveDate, IsActive
3. Service has CRUD operations: get current rate, set rate, convert to THB
4. SQL table script ready: database/tables/MotoRent.ExchangeRate.sql
5. Polymorphic serialization configured: JsonDerivedType on Entity.cs
6. DI registration complete: ExchangeRateService scoped, Repository singleton
</verification>

<success_criteria>
- [ ] `dotnet build` succeeds with no errors
- [ ] ExchangeRate entity has BuyRate, Currency, Source (Manual/API/Adjusted), EffectiveDate, IsActive
- [ ] ExchangeRateSources static class with Manual, API, Adjusted constants
- [ ] ExchangeRateService has GetCurrentRateAsync, SetRateAsync, ConvertToThbAsync, GetAllCurrentRatesAsync
- [ ] SQL table script follows JSON column pattern with computed columns and indexes
- [ ] Service registered in Program.cs DI container
</success_criteria>

<output>
After completion, create `.planning/phases/01-exchange-rate-foundation/01-01-SUMMARY.md`
</output>
